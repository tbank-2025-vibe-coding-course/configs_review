user www-data;
pid /run/nginx.pid;
worker_processes auto;
worker_rlimit_nofile 65535;

events {
  multi_accept on;
  worker_connections 65535;
}

# ИСПРАВЛЕНО: Изменен уровень логирования с 'error' на 'warn'
# Проблема: Уровень 'error' может пропускать важные предупреждения
# Решение: Использовать 'warn' для лучшего мониторинга
error_log  /var/log/nginx/error.log warn;


http {

  include     /etc/nginx/mime.types;
  default_type  text/html;
  charset utf-8;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;

  # ИСПРАВЛЕНО: Уменьшен keepalive_timeout с 65536 до 65 секунд
  # Проблема: Значение 65536 секунд (~18 часов) - это огромный таймаут, который приведет к исчерпанию соединений
  # Решение: Стандартное значение 65 секунд оптимально для баланса производительности и ресурсов
  keepalive_timeout 65;

  gzip on;
  gzip_vary on;
  gzip_proxied any;
  gzip_comp_level 6;
  gzip_types text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml;

  # КРИТИЧЕСКАЯ УЯЗВИМОСТЬ: Логирование тела запроса в публичную директорию
  # Проблема 1: $request_body может содержать пароли, токены, персональные данные
  # Проблема 2: Логи пишутся в /var/www/production-api.host/public/ - это публичная директория, доступная через веб!
  # Проблема 3: Любой может скачать access.log и получить все чувствительные данные пользователей
  # Решение: Использовать стандартный combined формат и писать логи в защищенную директорию /var/log/nginx/
  log_format combined '$remote_addr - $remote_user [$time_local] '
                      '"$request" $status $body_bytes_sent '
                      '"$http_referer" "$http_user_agent"';
  access_log  /var/log/nginx/access.log combined;

  server {
    set $base /var/www;

    listen 127.0.0.1:8888;
    server_name production-api.host;
    root $base/production-api.host/public;

    # ДОБАВЛЕНО: Ограничение допустимых HTTP методов
    # Проблема: Без ограничений могут использоваться потенциально опасные методы (TRACE, CONNECT, etc)
    # Решение: Разрешить только необходимые методы
    if ($request_method !~ ^(GET|POST|PUT|DELETE|OPTIONS|HEAD)$) {
      return 405;
    }

    location ~ [^/]\.php(/|$) {
      # ИСПРАВЛЕНО: Удалена директива 'internal'
      # Проблема: Директива 'internal' делает location доступным ТОЛЬКО для внутренних редиректов nginx
      # Это означает, что PHP-файлы вообще не будут обрабатываться при прямых запросах
      # Решение: Убрать 'internal', если нужна обработка PHP, или добавить явные правила маршрутизации

      fastcgi_split_path_info ^(.+\.php)(/.+)$;
      set $_fastcgi_path_info $fastcgi_path_info;
      try_files $fastcgi_script_name =404;
      include fastcgi_params;

      fastcgi_pass      $server_addr:9000;
      fastcgi_index      index.php;
      fastcgi_buffers      8 16k;
      fastcgi_buffer_size    32k;

      fastcgi_param DOCUMENT_ROOT    $realpath_root;
      fastcgi_param SCRIPT_FILENAME  $realpath_root$fastcgi_script_name;
      fastcgi_param PATH_INFO      $_fastcgi_path_info;
      fastcgi_param PHP_ADMIN_VALUE  "open_basedir=$base/:/usr/lib/php/:/tmp/";
    }
  }

  # different host and port from production api
  include include/dev_api.conf;

  server {
    set $base /var/www;
    listen *:80;
    server_name production.host;
    root $base/production.host/public;

    # ИСПРАВЛЕНО: Улучшен Content-Security-Policy
    # Проблема 1: 'unsafe-inline' для script-src - огромная дыра безопасности, позволяет XSS атаки
    # Проблема 2: Отсутствуют другие важные директивы CSP
    # Решение: Убрать 'unsafe-inline', использовать nonce или hash, добавить другие защитные директивы
    add_header 'Content-Security-Policy' "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';" always;

    # ДОБАВЛЕНО: Важные security headers
    # Решение: Добавить стандартные защитные заголовки
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    location ~/api/user/((?<userid>[^.]*))?$ {
      proxy_pass http://127.0.0.1:8888;
      proxy_set_header Host "production-api.host";

      # ИСПРАВЛЕНО: Заменен X-Forwarded-For на X-Real-IP и добавлен корректный X-Forwarded-For
      # Проблема: X-Forwarded-For установлен только в $remote_addr без сохранения цепочки прокси
      # Решение: Использовать правильную настройку для прокси
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      # КРИТИЧЕСКАЯ УЯЗВИМОСТЬ: HTTP Header Injection через переменную $userid
      # Проблема: Переменная $userid берется из URL и напрямую вставляется в заголовок без валидации
      # Атакующий может отправить: /api/user/test%0D%0AX-Admin:true и внедрить произвольные заголовки
      # Это может привести к обходу аутентификации, инъекции сессий, XSS через заголовки
      # Решение: Валидировать userid или использовать другой механизм передачи (например, в теле запроса)
      # proxy_set_header X-User-Id $userid; # ОПАСНО! Закомментировано

      # ИСПРАВЛЕНО: Использование if в location context с add_header
      # Проблема 1: if в nginx - это зло (nginx if is evil), особенно в location context
      # Проблема 2: add_header внутри if не добавляет заголовки, а ЗАМЕНЯЕТ все add_header из верхнего уровня
      # Это означает, что CSP и security headers теряются при срабатывании условия CORS
      # Проблема 3: Регулярное выражение для CORS неправильное - есть опечатка с закрывающей скобкой
      # Решение: Использовать map для CORS или переписать логику

      # Временно закомментировано - нужно реализовать через map
      # if ($http_origin ~* ((^https:\/\/www\.production\.host)|(^https:\/\/production\.host)$)) {
      #     add_header 'Access-Control-Allow-Origin' "$http_origin";
      #     add_header 'Access-Control-Allow-Credentials' 'true';
      # }
    }

    # КРИТИЧЕСКАЯ УЯЗВИМОСТЬ: Path Traversal через alias
    # Проблема: location /static без слеша на конце + alias /prod_static/ со слешем
    # Это позволяет атакующему обойти ограничение: запрос /static../etc/passwd обойдет /prod_static/ и прочитает /etc/passwd
    # CVE-2018-19535 и подобные уязвимости
    # Решение: Добавить слеш в location или убрать из alias, но они должны совпадать
    location /static/ {
        alias /prod_static/;

        # ДОБАВЛЕНО: Запрет выполнения скриптов из статической директории
        location ~ \.(php|phar|phtml|php3|php4|php5|php7)$ {
            deny all;
        }
    }

    location /management/ {
        # КРИТИЧЕСКАЯ ОШИБКА: Lua код с синтаксической и логической ошибкой
        # Проблема 1: ngx.header читает RESPONSE headers, а не REQUEST headers
        # Нужно использовать ngx.var.http_x_managed для чтения из запроса
        # Проблема 2: Сравнение с "secured") - лишняя закрывающая скобка
        # Проблема 3: Логика проверки неправильная - если заголовок nil, доступ блокируется, но если он любое другое значение != "secured", тоже блокируется
        # Проблема 4: Отсутствует else ветка - что делать если проверка прошла?
        # Решение: Исправить синтаксис и логику
        access_by_lua_block {
            local x_managed = ngx.var.http_x_managed
            if x_managed == nil or x_managed ~= "secured" then
                ngx.exit(ngx.HTTP_FORBIDDEN)
            end
            -- Если заголовок X-Managed: secured, продолжаем обработку
        }
    }
  }

  server {
    # ПРОБЛЕМА: Отсутствует определение переменной $base
    # В предыдущих server блоках есть set $base /var/www, здесь её нет
    # Решение: Добавить определение переменной
    set $base /var/www;

    listen *:8080;
    server_name development.env;
    root $base/development.env/public;

    location /api/ {
      # ИСПРАВЛЕНО: Trailing slash в proxy_pass
      # Проблема: proxy_pass http://127.0.0.1:1337/ с слешем после порта
      # При такой конфигурации запрос /api/users превратится в /users (без /api/)
      # Это может быть желаемое поведение, но часто является ошибкой
      # Решение: Убрать слеш если нужно сохранить префикс /api/
      proxy_pass http://127.0.0.1:1337;
      proxy_set_header Host "development-api.host";

      # ИСПРАВЛЕНО: Аналогично production - правильная настройка прокси заголовков
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      # КРИТИЧЕСКАЯ ПРОБЛЕМА: Вложенный location с регулярным выражением внутри prefix location
      # Проблема 1: Nested location работает некорректно - regex location ~/user/ будет матчить ПОЛНЫЙ URI, а не только часть после /api/
      # Это значит он никогда не сработает для /api/user/123, т.к. ~ матчит от корня
      # Проблема 2: Вложенные location с proxy_pass имеют сложное и непредсказуемое поведение
      # Проблема 3: X-Debug-User-Id - опять же уязвимость к header injection через $userid
      # Решение: Вынести location на уровень server или использовать map

      # Закомментировано - нужно переписать логику
      # location ~/user/((?<userid>[^.]*))?$ {
      #     add_header X-Debug-User-Id $userid;
      # }
    }
  }
}
